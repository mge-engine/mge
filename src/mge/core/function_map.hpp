// mge - Modern Game Engine
// Copyright (c) 2018 by Alexander Schroeder
// All rights reserved.
#pragma once
#include "mge/core/stdexceptions.hpp"

#include <functional>
#include <map>

namespace mge {

    /**
     * A map to store @c std::function object by a key (@c unsigned @c int)
     */
    template<typename T>
    class function_map
    {
    public:
        /**
         * Scope of an iteration. This is used to guard an iteration
         * that may result in a modification of the map - e.g. if
         * a stored function is called and removes itself.
         */
        class iteration_scope
        {
        public:
            /**
             * Create iteration scope.
             * @param m function map
             */
            explicit iteration_scope(function_map<T>& m)
                :m_map(m)
            {
                if(m.m_iteration_scope != nullptr) {
                    MGE_THROW(mge::illegal_state) << "Unsupported nested iteration scope";
                }
                m.m_iteration_scope = this;
            }

            /**
             * Destroy iteration scope.
             * Performs pending insert and delete operations.
             */
            ~iteration_scope()
            {
                for(const auto& p: m_insert_data) {
                    m_map.m_data[p.first] = p.second;
                }
                for(const auto& k: m_delete_data) {
                    auto it = m_map.m_data.find(k);
                    if(it != m_map.m_data.end()) {
                        m_map.m_data.erase(it);
                    }
                }
                m_map.m_iteration_scope = nullptr;
            }

            /**
             * Add an insert operation.
             * @param k key
             * @param f function
             */
            void add_insert(unsigned int k, const std::function<T>& f)
            {
                m_insert_data.push_back(std::make_pair(k, f));
            }

            /**
             * Add a delete operation.
             * @param k key
             */
            void add_delete(unsigned int k)
            {
                m_delete_data.push_back(k);
            }

            /**
             * Helper function for delete operation.
             * @param k key
             * @return @c true if key was in the data to be inserted
             */
            bool handle_delete(unsigned int k)
            {
                for(const auto& p: m_insert_data) {
                    if(k == p.first) {
                        m_delete_data.push_back(k);
                        return true;
                    }
                }
                return false;
            }

            std::vector<std::pair<unsigned int, std::function<T>>> m_insert_data;
            std::vector<unsigned int> m_delete_data;
            function_map<T>& m_map;
        };

        typedef unsigned int key_type;
        typedef std::function<T> value_type;
        typedef std::map<unsigned int, std::function<T>> map_type;

        /**
         * Constructor.
         */
        function_map()
        :m_sequence(1),
         m_iteration_scope(nullptr)
        {}

        /**
         * Copy constructor.
         * @param other copied instance
         */
        function_map(const function_map& other)
        :m_sequence(other.m_sequence),
         m_iteration_scope(nullptr),
         m_data(other.m_data)
        {
            if(other.m_iteration_scope != nullptr) {
                MGE_THROW(mge::illegal_state) << "Cannot copy function map during iteration";

            }
        }

        /**
         * Move constructor.
         * @param other moved instance
         */
        function_map(function_map&& other)
        :m_sequence(other.m_sequence),
         m_iteration_scope(nullptr),
         m_data(std::move(other.m_data))
        {
            if(other.m_iteration_scope != nullptr) {
                MGE_THROW(mge::illegal_state) << "Cannot copy function map during iteration";
            }
        }

        /**
         * Insert a function.
         * @param f inserted function
         * @return autogenerated key
         */
        key_type insert(const std::function<T>& f)
        {
            unsigned int k = m_sequence++;
            if(m_iteration_scope) {
                m_iteration_scope->add_insert(k, f);
            } else {
                m_data[k] = f;
            }
            return k;
        }

        /**
         * Erase an entry.
         * @param k key
         * @return @c true if data was found
         */
        bool erase(key_type k)
        {
            auto it = m_data.find(k);
            if(it != m_data.end()) {
                if(m_iteration_scope) {
                    m_iteration_scope->add_delete(k);
                } else {
                    m_data.erase(it);
                }
                return true;
            } else {
                if(m_iteration_scope) {
                    return m_iteration_scope->handle_delete(k);
                } else {
                    return false;
                }
            }
        }

        /**
         * Returns an iterator the the first element. It is necessary
         * that an @c iteration_scope is active.
         * @return iterator to first element, content type is @c std::pair<key_type, T>
         */
        typename map_type::const_iterator begin() const
        {
            if (m_iteration_scope == nullptr) {
                MGE_THROW(mge::illegal_state) << "Try to iterate on map without iteration scope";
            }
            return m_data.begin();
        }

        /**
         * Returns an iterator to the position after the last element. It is
         * necessary that an @c iteration_scope is active.
         * @return iterator to the position after the last element
         */
        typename map_type::const_iterator end() const
        {
            if (m_iteration_scope == nullptr) {
                MGE_THROW(mge::illegal_state) <<  "Try to iterate on map without iteration scope";
            }
            return m_data.end();
        }

        unsigned int     m_sequence;
        iteration_scope *m_iteration_scope;
        map_type         m_data;
    };

}
